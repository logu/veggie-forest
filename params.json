{
  "name": "Veggie-forest",
  "tagline": "Veggie forest: découvrez vos fruits et légumes",
  "body": "Overall, the project had a lot of turnover and doesn't had a proper architecture. And there are several teams working on the same codebase. So, the final result is an application which is hardly maintainable and which may produce bugs for each modifications.\r\n\r\nThe purpose of this study is to look for a way to find an ideal architecture for a large scale web app that makes heavy use of REST API.\r\nIt will try to bring to the codebase an application level structure by applying a structural pattern and a bunch of behavioral patterns to help structure the business logic. \r\n\r\nThere is no questions about JavaScript MVC architectures, they are standard when creating large scale web app. MVC only helps to separate reponsibilities of a low level logics. It provides a separation between the data and visualization, but it doesn't have a concept for coordination among an application's modules.\r\n\r\n\r\n# Environment / technical stack\r\n\r\n\r\n### Javascript libraries\r\n- MV* library ```Backbone``` \r\n- A collection of common design pattern applied with Backbone: ```Marionette``` \r\n\r\n### Dependencies management: \r\n- Package manager: ```npm```\r\n- Dependency manager: ```browserify```\r\n\r\n### Build system\r\n- Tasker: ```gulp```\r\n\r\n### Test \r\n- Test runner: ```Karma```\r\n- Test framework: ```Mocha```\r\n- Assertion library: ```Chai```\r\n- Test spies, stubs and mocks: ```SinonJS```\r\n- Code coverage: ```Istanbul```\r\n\r\n# Structural level \r\n\r\nAs the application get larger and larger, it’s important to decouple the various functional areas. Decoupling them allows a greater flexibility by letting each functional chunk to be changed, without affecting the other areas. This is where structural patterns play a critical role. The structural patterns are concerned with how classes and objects are composed to form larger structures. \r\nThere are quite a few (Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy)\r\n\r\n**The composite architecture seems to fit the best with the chosen technical stack.**\r\n\r\n![Global architecture](https://cloud.githubusercontent.com/assets/1543609/11334585/52dfcac2-91d6-11e5-8518-bf6b5837dbed.png)\r\n\r\n\r\n***\r\n# App \r\n\r\n* Manage the sub applications\r\n* Plays the role of mediator for those sub applications\r\n* Has a layout to enable the use of modules common to multiple sub applications\r\n* Has access to the entities (data manager)\r\n* Has access to the services (singleton modules providing common functionalities which doesn’t rely on instantiated classes)\r\n* Communicates with its sub applications through the application channel\r\n\r\n***\r\n\r\n# Subapp\r\n## Description \r\n\r\nEach subapp manage its modules and plays the role of mediator for those modules, it communicates with the application through the application channel and with its modules through it’s own subapp channel. It has its own router which will help to navigate between pages.\r\n\r\nThe entry point of the subapp is index.js (sandbox). \r\nThe subapp is build using pages which most of the time is linked to a screen of the app.\r\nThe navigation between pages of the subapp is insured by attached router.\r\n\r\n## File structure\r\n\r\nAn example `subapp` subapp :\r\n\r\n```\r\n└── subapp\r\n    ├── pages\r\n    | └── subapp-home.js\r\n    ├── sass\r\n    | └── subapp.scss\r\n    ├── templates\r\n    | └── subapp-layout.hbs\r\n    | └── subapp-home-layout.hbs\r\n    ├── views\r\n    | └── subapp-layout-view.js\r\n    ├── index.js\r\n    └── router.js\r\n```\r\n\r\n### Pages \r\nUsually used to display a screen of the app,\r\na page could include one or several Modules.\r\n\r\nTo initialize a page :\r\n\r\n```\r\nvar Marionette = require('backbone.marionette');\r\n\r\n// List of the Modules used in the page\r\nvar Example = require('../_modules/example-name');\r\n\r\n// A Page is associate to a View Layout\r\nvar ExampeLayout = require('../views/example-name-layout-view');\r\n\r\nmodule.exports = Marionette.Object.extend({\r\n\r\n  initialize: function(options) {\r\n    // container, layout and parentChannel are initialized in the parent\r\n    this.container = options.container;\r\n    this.layout = new ExampeLayout();\r\n    this.container.show(this.layout);    \r\n    this.parentChannel = options.parentChannel;\r\n    \r\n    // Initializing data\r\n    this.initData();\r\n    // Initializing modules (using previously initialized data)\r\n    this.initModules();\r\n    // Fetch data\r\n    this.fetchData();\r\n  }\r\n  \r\n});\r\n```\r\n\r\n### Sass\r\nAll the styles needed for the subapp.\r\n\r\n### Templates\r\nAll the templates needed for the layouts.\r\n\r\n### Views\r\nMost of the time it will be a layout-view to be able to structure the subapp or the pages.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}